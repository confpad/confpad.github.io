- title: At scale, everything is hard
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Paul Dix
      twitter: pauldix
      github: pauldix
      website:
  slides:
    - https://speakerdeck.com/pauldix/at-scale-everything-is-hard
  videos:
    - https://youtu.be/80rY626zCfk
  description: |-
    Paul reviews the journey of the development of InfluxDB from version 0.9 in 2015 to the 2.0 version that they are working on in 2018. He talks about building their own storage engine, moving from a monolithic database to a services based containerized data platform and scaling out the development team.

- title: Kubernetes 101
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Bridget Kromhout
      twitter: bridgetkromhout
      github: bridgetkromhout
      website:
  slides:
    - https://www.slideshare.net/bridgetkromhout/kubernetes-101-dotscale
  videos:
    - https://youtu.be/N7gxfroizbA
  description: |-
    Must we really orchestrate our containers, or could they perhaps just do some improv jazz? The container landscape has converged on Kubernetes. Bridget talks about how, what, why, and other such excellent questions. You’ll come away with ideas for learning and sharing about k8s.

- title: Just-Right Consistency
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Marc Shapiro
      twitter:
      github:
      website:
  slides:
    - https://pages.lip6.fr/Marc.Shapiro/slides/JRC_dotScale_2018-06-01.pdf
  videos:
    - https://youtu.be/lO-UfHASUSE
  description: |-
    In a distributed data store, the CAP theorem forces a choice between strong consistency (CP) and availability and responsiveness (AP). To address this issue, we take an application-driven approach, Just-Right Consistency (JRC). JRC derives a consistency model that is sufficient to maintain the application invariants, otherwise remaining as available as possible. JRC leverages application invariant-maintaining patterns. Two, ordered updates and atomic grouping, are compatible with concurrent and asynchronous updates, orthogonally to CAP. In contrast, checking a data precondition on partitioned state is CAP-sensitive. However, if two updates do not negate each other's precondition, they may legally execute concurrently. Updates must synchronise only if one negates the precondition of the other. The JRC approach is supported by the CRDT data model that ensures that concurrent updates converge; by Antidote, a cloud-scale CRDT data store that guarantees transactional causal consistency; and by the CISE static analyser that verifies whether application invariants are guaranteed. This research is supported in part by FP7 SyncFree, H2020 LightKone, and by ANR project RainbowFS.

- title: Demonstrating your Architecture
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Julio Faerman
      twitter: julioaws
      github: jfaerman
      website:
  slides:
    - https://speakerdeck.com/faermanj/demonstrating-your-architecture
  videos:
    - https://youtu.be/ubpB4VQrBeE
  description: |-
    How do you demonstrate your software is ready? However you define "demonstrate" or "ready", sharing how applications fits requirements is important not only internally at your organization, but possibly valuable to community peers worldwide. Julio addresses five non-functional requirements: Security, Reliability, Performance, Cost Optimization and Operational Excellence. Let's explore how to measure and share decisions to satisfy them to the expected level using the best of cloud innovations and tools.

- title: Distributions and package management in the containers era
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Lucas Nussbaum
      twitter: lucasnussbaum
      github: lnussbaum
      website:
  slides:
    - https://www.slideshare.net/nussbauml/distributions-and-package-management-in-the-containers-era
  videos:
    - https://youtu.be/hnWnKIZmPyA
  description: |-
    Lucas looks at what can be learned from successes and failures in the world of distributions, and maybe transferred to language package managers. Topics discussed include Quality Assurance tools, collaboration with derivative distributions and upstream projets, and using distributions tools to deploy your own software.

- title: Git as a continuous manager
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Matthias Dugué
      twitter: m4d_z
      github: m4dz
      website:
  slides:
    - https://talks.m4dz.net/git-continous-manager/?format=flash&lang=en#1
  videos:
    - https://youtu.be/N181gp9gouY
  description: |-
    Continuous deployment could be a nightmare, even when using the right tools. There's many of them available: CI servers, Provisionner, Containers… If you have to deal with feature-flipping too, it starts to be Hell. What if we try to get back to the basics and use only one tool, Git, for every of our tasks: from versioning to deploying? Matthias shows which solutions exists to automate deployment and feature-flipping, and compares them to the advanced workflow of Git as an ordonnancer for deployment and feature-flipping.

- title: 'Nano-node: Intelligent Hard Drives in Large Storage Infrastructures'
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Enrico Signoretti
      twitter: esignoretti
      github: esignoretti
      website:
  slides:
    - https://www.slideshare.net/openio/nanonode-intelligent-hard-drives-in-large-storage-infrastructures
  videos:
    - https://youtu.be/f202h-2tecs
  description: |-
    Put CPU next to hard drives or SSDs for a new approach to large scale out infrastructures, improving overall efficiency while reducing failure domains. Enrico describes how to overcome the limitations imposed by fat serves and how to scale storage and compute for next generation workloads. The concept of offloading some CPU tasks to the storage infrastructure is not entirely new but now, thanks to the power of modern CPUs, their efficiency, and smaller SoC (system on chip) designs, it is possible to do more and bring the CPU closer to data instead the opposite. By doing so, each device can perform some computational tasks that were, in the past, carried out on the CPU. Data is not moved anymore, saving bandwidth, improving overall parallelism, and enhancing overall system efficiency. With an adequate amount of RAM and connectivity, they can perform a lot of simple tasks. Those operations, executed by storage devices, make it possible to keep data local, minimizing latency, while improving overall parallelization and system efficiency. At the same time, the failure domain is smaller, and this improves the scalability of the entire infrastructure.

- title: Serverless, Revealed!
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Daniel Maher
      twitter: phrawzty
      github: phrawzty
      website:
  slides:
  videos:
    - https://youtu.be/0s8ATQmhQPE
  description: |-
    Serverless is being heralded as the next big thing in computing - but as you'll discover in this lightning talk, there's nothing new under the sun. The architectural underpinnings, technological constraints, and incumbent providers are all familiar. Practically speaking, Serverless still requires you to understand your software, your workload, and your use-case; in other words, there is no magic.

- title: Observability tips with HAProxy
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Willy Tarreau
      twitter: willytarreau
      github: wtarreau
      website:
  slides:
    - https://www.slideshare.net/WillyTarreau/observability-tips-for-haproxy
  videos:
    - https://youtu.be/1JSX9ch04eY
  description: |-
    Willy covers multiple aspects of observability using the HAProxy load balancer. He also tries to suggest the smallest set of very relevant metrics to watch in order to detect when something starts to go wrong, and immediately spot what, where and help figure why.

- title: Three heretical opinions about the future of time-series data
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Mike Freedman
      twitter: michaelfreedman
      github: mfreed
      website:
  slides:
    - https://www.slideshare.net/TimescaleDB/three-heretical-opinions-about-the-future-of-timeseries-data
  videos:
    - https://youtu.be/r4jMunPhwzw
  description: |-
    TimescaleDB offers three seemingly heretical insights about data: (1) all data is time-series; (2) what you've heard about it is wrong; and (3) SQL should and does remain the lingua franca for databases. These insights enable new possibilities for architecting database systems, and Mike briefly discusses how TimescaleDB, an open-source time-series database purpose-built on top of PostgreSQL, realizes these needs. TimescaleDB offers three seemingly heretical insights about data and the future of data storage: 1- All data is time-series data. 2- What you've heard about modeling and storing time-series data is wrong. 3- Time-series data has an inherently relational structure; use SQL. Time-series data is quickly becoming a major workload across practically every industry. Acting on time-series data enables us to understand the past, have more control over the present, and predict the future. Putting it to use is a critical business opportunity. Mike discusses why these insights matter and how they enable new possibilities for architecting database systems. He also reviews how TimescaleDB, an open-source time-series database purpose-built on top of PostgreSQL, enables the flexibility, power, and performance needed to realize time-series data storage and analytics.

- title: The Data of Infrastructures
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Jeremy Edberg
      twitter: jedberg
      github: jedberg
      website:
  slides:
  videos:
    - https://youtu.be/KUxHINjOcA8
  description: |-
    Our infrastructures generate a lot of metadata. However, true insight comes from the derivative data -- the data that we derive from the metadata. Jeremy gives you tips and strategies for collecting good metadata and how to use that to generate unique and actionable insights about your infrastructure.

- title: Data Cartography
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Preeti Vaidya
      twitter:
      github:
      website:
  slides:
    - https://speakerdeck.com/pv2259/data-cartography
  videos:
    - https://youtu.be/dAM8SPUOXNw
  description: |-
    Technology has gone through many iterations - Mainframes, to Client-Service Models, and now Isomorphic Applications. The world of Data Management has evolved too, from Databases, to Warehouses, Sharehouses, and Data Lakes, consequently Data Catalogues. Each of these iterations have given us learnings, and paved the way for better solutions! The constantly changing data landscape has helped us look at new ways of solving problems, but at the same time, has also introduced new challenges. Preeti addresses the problem of picking the right Data Store, and elaborates on a four step Design Paradigm to help you pick the right one!

- title: Designing Scalable and Extendable Data Pipeline for Call of Duty Games
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: Yaroslav Tkachenko
      twitter: sap1ens
      github: sap1ens
      website:
  slides:
    - https://www.slideshare.net/sap1ens/designing-scalable-and-extendable-data-pipeline-for-call-of-duty-games
  videos:
    - https://youtu.be/Vn_EJoreZfk
  description: |-
    The Call of Duty game franchise generates a massive amount of data telemetry. Activision has been developing its data pipeline for a while, and they learned how to scale it not only in terms of traffic, but also in terms of supporting more games and more use-cases. Yaroslav dives into their unified message envelope and why it's so important to have a proper Kafka topic naming convention.

- title: Istio, we have a problem! Understanding and fixing bugs with a service-mesh
  type:
  level:
  time: 2018-06-01
  room:
  authors:
    - name: David Gageot
      twitter: dgageot
      github: dgageot
      website:
  slides:
  videos:
    - https://youtu.be/ybVK7cd3TqQ
  description: |-
    Istio, we have a problem! We've just deployed a shiny new set of micro-services and it behaves in a strange manner. Hard to say why with so many moving parts... Let's leverage the newly installed service mesh to understand what we've deployed. Find the root problem. Fix it. And then do a proper, non trivial, blue-green deployment of the updated version. That will involve the Service Graph, Prometheus monitoring, Grafana Dashboards, Traffic mirroring, all orchestrated in a simple manner by Istio.
